%!TEX root = ../main.tex

\section{Core Literature Section: Constraint-Based Typing}

As previously mentioned, constraint-based typing is a widely adopted approach for implementing type inference systems, especially in dynamically typed languages. This section explores the Hindley-Milner type system, which will serve as the foundational basis for the type inference system designed for MiniLua.

\subsection{Hindley-Milner Type System}

The Hindley-Milner (HM) type system, also known as Damas-Milner type system, is one of the foundational algorithms for type inference in statically-typed functional programming languages. It was first implemented in a programming language was the ML (Meta Language) programming language, then later adopted by other languages such as Haskell and OCaml.

The HM type system is based on the concept of polymorphism, where values and expressions can be described as having polymorphic types. A type being polymorphic meaning that its type can be generalized to represent multiple specific types. The generalization of types allows for greater flexibility and code reusability, as functions and expressions are allowed to operate on a wider range of types without explicit handling of each specific type. However, monomorphic types, types that represent a single specific type, are also supported in the HM type system. Polymorphic types can be deduced to monomorphic types through the use of constraint generation and unification to require specific types in certain contexts. The resulting type after unification is referred to as the principal type, which is the most general type that satisfies all constraints for a given variable type.

At the time of its first implementation, in ML, the HM type system was contradictory to the popular type systems of the time in languages such as Pascal and C. These type systems only supported monomorphic types, requiring explicit type annotations for all variables and expressions. This came at a benefit of human readability for how memory was being laid out for various types and variables, a strong quality for systems-level programming. However, it limited the flexibility of the language as functions and expressions could only operate on specific types per implementation. This meant that for many of the these monomorphic language, true abstraction and generalization of code was difficult if not impossible to achieve.

Successors to some of these languages, such as C++ and Java, later implemented forms of polymorphism through the method of subtyping. This method of subtyping allowed for a concept called overloading, where multiple implementations of a function or method could be defined for different specific types. However, this approach still required explicit type annotations and handling for each specific type, leading to code duplication and increased complexity. Additionally, this approach did not allow for true polymorphism, as functions and expressions could not operate on a wider range of types without explicit handling of each specific type. An implementation of the HM type system's approach to polymorphism would later result in the development of generics in many languages such as C++ and Java, allowing for true polymorphism and code generalization.

\subsection{Let-Polymorphism}

The decision to generalize types for variables and expressions must have guidelines to ensure that the type system remains sound and consistent. In the case of parameters of a function, the type must ensure that it is not polymorphic in a way that would allow for conflicting types to be used in different contexts. The way in which the HM type system handles this is through the use of let-polymorphism.

Let-polymorphism is the decision to only allow for polymorphic types to be generalized at let-bindings. A let-binding is a construct that allows for the definition of a variable and its associated value or expression. By restricting the generalization of types to only occur at let-bindings, the HM type system ensures that polymorphic types are only introduced in a controlled manner, preventing conflicting types from being used in different contexts. This restriction helps maintain the soundness and consistency of the type system, as it prevents the introduction of polymorphic types that could lead to type errors or inconsistencies. Type variables that are not bound by a let-binding are considered free type variables, and are treated as monomorphic types during the type inference process. This means that they cannot be generalized to polymorphic types, and must be assigned a specific type based on their usage and context within the code.

\subsection{Hindley-Milner for Functional Languages}

Functional programming is a programming paradigm that treats computation as the representation of mathematical functions. It is a pure form of programming that emphasizes immutability and deterministic behavior. It achieves this deterministic behavior through the use of data being immutable, meaning that once a value is assigned to a variable, it cannot be changed. This immutability ensures that functions always produce the same output for the same input, leading to predictable and reliable behavior. Functional programming languages often support higher-order functions, which are functions that can take other functions as arguments or return functions as results. This allows for greater abstraction and code reuse, as functions can be composed and manipulated in a more flexible manner.

It is through these characteristics of functional programming that the HM type system was able to be effectively implemented in functional programming languages such as Haskell. The immutability of data in functional programming ensures that variables and expressions have a consistent type throughout their lifetime, making it easier to infer types based on their usage and context. Additionally, the use of higher-order functions allows for greater abstraction and code reuse, which aligns well with the polymorphic nature of the HM type system. The deterministic behavior of functional programming also ensures that functions and expressions can be analyzed in isolation, without the need to consider the broader context of the program. This allows for more accurate type inference, as the type system can focus on the specific behavior of individual functions and expressions.

\subsection{Hindley-Milner for Imperative/Dynamic Languages}

Contrary to the functional programming paradigm, imperative programming is a programming paradigm that focuses on describing how a program operates through a sequence of statements that change a program's state. Unlike functional programming, imperative programming allows, even encourages, the use of mutable states. This mutability allows for variables to be reassigned to different values throughout their lifetime, leading to more complex and dynamic behavior. Imperative programming relies on control flow constructs, such as loops and conditional statements, to determine the order of execution and the flow of data within a program. While allowing for greater flexibility and dynamic behavior, it is this strength that complicates the implementation of a type inference system based on the HM type system.

The mutability of data in imperative programming means that variables and expressions can change their type throughout their lifetime, making it more difficult to infer types based on their usage and context. Additionally, the use of control flow constructs introduces additional complexity, as the type system must consider the broader context of the program when analyzing functions and expressions. This can lead to situations where the type of given variables or expressions is dependent on the specific path taken through the program, making it more challenging to accurately infer types.

\subsection{Hindley-Milner for Lua-like Languages}

Lua is described as a multi-paradigm programming language, supporting imperative, functional, procedural, and object-like oriented programming styles. Despite this multi-paradigm nature, Lua's core design and usage patterns are primarily imperative. This imperative nature of Lua introduces challenges for implementing a type inference system based on the HM type system, as previously discussed. The extent of Lua's dynamic features, such as a dynamic table structures and a mutable global state, result in additional complexity for type inference. Pure type inference systems based on the HM type system often struggle to effectively analyze Lua code due to these dynamic features and programming patterns. To effectively implement a type inference system for a Lua-like language, it is necessary to simplify or restrict some of these dynamic features, as is done in MiniLua. By focusing on a subset of Lua that retains its core syntax and semantics while reducing its complexity, it becomes possible to design a type inference system that can effectively analyze Lua-like code.