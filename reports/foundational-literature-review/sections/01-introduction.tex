%!TEX root = ../main.tex

% 1. Type Inference for a Lua-like Language
\section{Type Inference for a Lua-like Language}

% 1.1 The Volatility of Dynamic Typing
\subsection{The Volatility of Dynamic Typing}

Over the past several decades, dynamically typed programming languages have surged in popularity. Languages such as Python, JavaScript, Ruby, and Lua have been widely adopted due to their concise syntax, rapid prototyping capabilities, and the absence of explicit type declarations. As noted by the creators of Lua, this design philosophy prioritizes "mechanisms" over "policies," allowing for high flexibility during early development \cite{Ierusalimschy:1996:LEE:226264.226283}. However, while this flexibility accelerates prototyping, it reveals significant costs as projects scale. A defining trait of dynamic languages is that type validation occurs at runtime, meaning errors that could have been resolved statically are only discovered during execution. As established in early static analysis research, inferring types in such environments is notoriously difficult because the flow of values is not explicitly constrained \cite{Aiken:1991:STI:99583.99611}. Consequently, this leads to increased development costs, where bugs manifest only under specific runtime conditions, causing delays and reliability issues.

Lua is a prime example of this volatility. Despite its challenges, it has gained massive traction in the gaming industry due to its ease of embedding, powering logic in titles such as \emph{World of Warcraft}, \emph{Balatro}, and \emph{Angry Birds}. Luau, a high-performance derivative, powers the Roblox platform, serving millions of users \cite{Brown:2021:GOL:3486606.3486770}. Given this widespread adoption, enhancing Lua's safety through static analysis would yield substantial benefits. However, Lua is particularly difficult to effectively statically-analyze. Its reliance on a single data structure (the table), first-class functions, and metatables presents a "dynamic" barrier that traditional inference engines struggle to process \cite{Ierusalimschy:1996:LEE:226264.226283}. Lin (2015) categorizes these as "exotic" features, noting that metatables specifically complicate the operational semantics required for formal verification \cite{Lin2015OperationalSF}.

% 1.2 The Gap in Existing Solutions
\subsection{The Gap in Existing Solutions}

While there have been attempts to introduce static typing to Lua, current solutions prioritize developer convenience over theoretical abidance. Industry standards for dynamic languages, such as TypeScript, often utilize "erasure" semantics, where types are removed at runtime and safety is not guaranteed if data flows in from external sources \cite{Bierman:2014:UT:2660193.2660237}. In the Lua ecosystem, Typed Lua introduces gradual typing but struggles to model table mutation accurately. Similarly, Luau implements a "non-strict" mode designed to minimize false positives rather than guarantee correctness, explicitly trading soundness for usability \cite{Brown:2021:GOL:3486606.3486770}. These systems often lead to either overly permissive inferences that fail to catch errors or require extensive manual annotations that negate the concise nature of the language. There remains a lack of a solution that offers a "pure" inference model—one that guarantees safety without requiring the developer to manually annotate every variable.

The goal of this project is to design and implement "MiniLua," a language subset paired with a pure Hindley-Milner type inference system. Unlike existing gradual approaches, MiniLua prioritizes \emph{soundness} and \emph{completeness}. Following the definitions provided by Pierce (2002), the system aims to satisfy the preservation and progress theorems, ensuring that if a program type-checks, it will not get "stuck" at runtime \cite{Pierce:2002:TPL}. By restricting the most volatile features of Lua—specifically global state mutation and dynamic metatable assignment—MiniLua seeks to prove that a Lua-like language can be statically verified with the same rigor as functional languages like Haskell, providing a foundation for robust software development in the Lua ecosystem.